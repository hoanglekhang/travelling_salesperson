# travelling_salesperson
Assessment Meeting

Each group must schedule a time with me outside of class to explain their code. This meeting enables me to fairly assess your project under the rubric, as it gives you a chance to explain and defend your design decisions. Before you begin work on the project, please email me with a few possible 20-minute blocks of time selected from the possibilities below. Choose a time that maximizes the number of group members that can attend.

4/9: 12:00 - 2:00
4/10: 2:00 - 4:00
4/11: 12:00 - 2:00
4/12: 2:00 - 3:00
 

Project Description

We will take a look at the Travelling Salesperson ProblemLinks to an external site. (TSP). The input to the problem is a list of cities we must visit together with perfect information about the distance between any two cities. Our goal is to choose any starting city, visit every other city exactly once, and return to the starting city in such a way that the total travel distance is minimized.

Your group will implement three algorithms to address TSP: a greedy selection algorithm, an evolutionary mutation algorithm, and an exhaustive backtracking algorithm. Some design requirements and considerations for each algorithm are presented below. Before writing any code, your group must collectively write a pseudocode description of each algorithm and discuss it with the instructor.

 

General Specifications

A proposed TSP route can be represented as a permutation of the cities. Suppose we have to visit cities A, B, C, and D. The string BACD corresponds to the route that begins at city B, visits A, then C, then D, then returns to city B.
For the purposes of this project, you may not use any Python libraries that relate to permutations. Doing so might trivialize some portions of the implementation.
Your top-level functions will each take the address of a text file containing distance information as input. You may not hard code the distance information, but you may rely on the formatting of the text. The Python functions splitLinks to an external site. and floatLinks to an external site. will be useful in parsing the text file into a more useful format.
The "names" file contains the names of the cities represented in the "distances" file in the correct order. (That is, the name in row i of the "names" file corresponds to row i and column i of the "distances" file.)
The entry in row i and column j of the "distances" file is the distance from city i to city j.
Decide early in your discussions how certain aspects of the problem will be represented in code. How will you represent a tour? How will you store the data from the text files? Making clear decisions early in the design process will help ensure that code written by separate individuals is compatible.
 

Greedy Algorithm

tsp_greedy(name_file, distance_file): This function should take as input the name and distance information found in name_file and distance_file. It should print the TSP route (as a list of names of cities) generated by following your greedy selection process as well as the total distance.
A greedy algorithm should build a solution by making a series of "greedy" selections; the selection seems optimal so long as you don't account for the way in which is has constrained your future choices. How can you build a TSP route by a series of small decisions? What is a greedy selection criterion in this case? The Python function minLinks to an external site. could be used in this process.
A greedy algorithm must also ensure that it does not make any illegal selections during its execution (i.e., a selection that does not yield a valid solution in the end). Could your greedy criterion result in an illegal selection? If so, how will you prevent this?
Write the greedy algorithm in such a way that an n city input generates n greedy solutions: one for each possible starting city. For example, with four cities, I should try 
 as the first city and run the greedy algorithm to see what solution it generates. Next, I should try 
 as the first city and run the greedy algorithm to see if I get a different solution. Continue similarly with 
 and 
 as the first cities. Print only the best of these four solutions.
 

Greedy Algorithm Pseudocode

Input: Matrix of distances between each pair of n cities
Output: Best TSP solution according to n executions of a greedy algorithm (one execution for each possible starting city)

FOR each starting city
    INITIALIZE current tour as tour containing only starting city
    WHILE there are unvisited cities
        Add nearest unvisited city to current tour
    IF current tour is shorter than shortest tour so far
        Update shortest tour to current tour
PRINT string representing shortest tour and its total distance

 

Evolutionary Algorithm

tsp_evolution(name_file, distance_file): This function should take as input the name and distance information found in name_file and distance_file. It should print the TSP route (as a list of names of cities) generated by following the evolutionary procedure discussed below as well as the total distance.
Initialize: Generate any TSP solution. Typically you want this initial solution to be rather mundane and easy to understand.
Mutate: Given a TSP solution, make a small random change that is guaranteed to result in another solution. (You may use the Python randomLinks to an external site. package in this step.)
Select: Given a collection of offspring produced by in the Mutate stage, select the "best" one. (What is meant by "best" in TSP?)
Terminate: Terminate after five "stagnations" have occurred (more detail below). Return the best of these five routes.
A "stagnation" is a generation of offspring that sees no improvement in fitness over the parent. When you encounter a stagnation:
Save the current parent somewhere. (We might later decide this is the best solution we can find.)
Mutate the parent three times (to get far away from the local optimum you are currently stuck at). Accept these mutations even if they produce a worse solution (they most likely will). Call this solution s.
Return to the Mutate stage, behaving as if your Initialize step had resulted in solution s.
 

Backtracking Algorithm

tsp_backtrack(name_file, distance_file): This function should take as input the name and distance information found in name_file and distance_file. This function should only read in the files, put the data into a useful form (the distance information will need to be global), and perform the initial recursive call (described below). The recursion itself should be handled by a separate function (described below). The function tsp_backtrack should print the optimal tour (as a list of names of cities) as well as the total distance.
The tsp_backtrack function is not the appropriate function to use for recursive calls since the inputs are static text file addresses. You will want to write a separate function tsp_recursion that takes a partial tour and remaining cities as input (just like in the permutation example). All the recursive backtracking logic will be inside tsp_recursion, not tsp_backtrack.
For the sake of space efficiency, do not store every solution. Instead, keep a record of the best solution found so far as a global variable and update it when needed.
Not every permutation describes a unique TSP route. Consider the route 
. The rotations 
, 
, and 
 all describe the same routes but with different starting cities (which all yield the same total distance). The flips (visiting the cities in reverse order) of each of the routes are also redundant: 
, 
, 
, and 
. For the sake of time efficiency, your search tree should not generate these redundant solutions.
Rotations can be avoided by a putting a simple constraint on the starting city. What is it?
Flips are trickier, but here's an observation that helps: Suppose we have six cities and our starting city is 
. Suppose further that we have generated all tours of the form 
, where the dots are filled in by the other three cities in all possible ways. We have no need to generate any tour of the form 
, since any one of them can be flipped to look like the previous form. (For example, the flip of 
 is 
.) In the search tree, we should therefore begin by generating the second and last cities in the same step as an unordered pair, creating a branch for 
 but not 
.
Even with the efficiencies described above, TSP has an obscene number of solutions (
 for 
 cities, in case you like that sort of thing). Backtracking will very likely be too slow for the large data set I provided.
 

Submitting the Project

The project will be assessed according to this rubric. Some things to keep in mind for this project in particular:
All functions should have a detailed docstring, descriptive variable names, and be appropriately commented. (Documented and Maintainable)
All three algorithms will need (among other things) a way to read in data from the text files and compute the total distance of a tour. Such common elements should be accomplished by auxiliary functions. (Adaptable and Reusable)
Backtracking and (to a lesser extent) mutation algorithms can be extremely time-intensive, especially for problems with huge search spaces. Scrutinize your code for ways to make the execution as efficient as possible. Are there any lines that can be omitted? Is there a way to accomplish your goal with fewer commands? (Efficient and Elegant)
All functions should reside in a single notebook file on Github.
Each group member should maintain a work log throughout the project. The log should be little more than an a bulleted list stating specifically what you worked on and how much time was spent.
By the due date (notice it's on Monday), upload a zipped folder to Canvas containing the following:
your pseudocode,
your code,
each group member's work log,
screenshots showing the output of the following commands:
tsp_greedy('thirty_cities_names.txt', 'thirty_cities_dist.txt') along with the total distance of this tour
tsp_mutation('thirty_cities_names.txt', 'thirty_cities_dist.txt') along with the total distance of this tour
tsp_backtrack('seven_cities_names.txt', 'seven_cities_dist.txt') along with the total distance of this tour
Attend your scheduled assessment meeting.